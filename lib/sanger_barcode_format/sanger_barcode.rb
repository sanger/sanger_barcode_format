require 'sanger_barcode_format/builders'

module SBCF
  # Barcodes generated by Sequencescape and other applications have two
  # representations, a human readable form, and an ean13 representation. The ean13
  # is regularly used to generate physical barcodes, and is returned by the various
  # barcode scanners. Meanwhile the human readable form is often used when items
  # are searched for manually, particularly when there is no physical access to the
  # item itself.
  #
  # Barcodes are comprised of three components:
  #   - A prefix: represented by two uppercase letters in the human readable form,
  #   and encoded as three digits in the ean13. Please be aware that some encoded
  #   prefixes begin with zero, which can get stripped under some circumstances.
  #   Prefixes generally identify the type of item which has received the barcode
  #   and are registered in an external database.
  #   - A number: A number between 0 and 9999999 inclusive. The human form is not
  #   typically zero padded.
  #   - A checksum: In addition to the ean13 of the machine printed version,
  #   barcodes also contain a single character / two digit internal checksum used to
  #   identify input errors of the human readable form.
  #
  # In addition, printed forms will contain the standard EAN checksum digit. This
  # checksum is included in the output of this gem and does not need to be
  # recalculated .
  class SangerBarcode
    attr_reader :prefix, :number
    extend Builders
    # rubocop:disable Metrics/ParameterLists
    # Create a new barcode object.
    # Either:
    # - Provide a prefix and number
    # - Provide a machine barcode (Ean13)
    # - Provide a human readable barcode (Eg. DN12345) If checksum required is set to true will raise ChecksumRequired
    #   if the internal checksum character is missing.
    #
    # @param [String||SangerBarcodable::Prefix] prefix The two letter prefix or a Prefix object
    # @param [Int] number The unique number, up to 7 digits long
    # @param [String] checksum Optional human readable checksum character.
    # @param [Sting||Int] machine_barcode Ean13 barcode as red by a scanner
    # @param [String] human_barcode Human readable barcode eg. DN12345R
    # @param [Bool] checksum_required If set to true will enforce presence of checksum on human_barcode input
    # @return [SangerBarcodable::SangerBarcode] A representation of the barcode
    def initialize(
      prefix: nil, number: nil, checksum: nil,
      machine_barcode: nil,
      human_barcode: nil, checksum_required: false
    )
      argument_error! unless [(prefix && number), machine_barcode, human_barcode].one?
      self.prefix = prefix
      self.number = number
      self.checksum = checksum
      self.machine_barcode = machine_barcode.to_i if machine_barcode
      @checksum_required = checksum_required
      self.human_barcode = human_barcode if human_barcode
    end
    # rubocop:enable Metrics/ParameterLists

    # Returns the machine readable ean13, or nil if no barcode could be generated
    #
    # @return [Int] The machine readable ean13 barcode
    def machine_barcode
      @machine_barcode ||= calculate_machine_barcode
    end

    # As with machine_barcode but raises InvalidBarcode if no barcode could be generated
    #
    # @return [Int] The machine readable ean13 barcode
    def machine_barcode!
      machine_barcode || raise(InvalidBarcode, "Could not convert #{@human_barcode} to machine_barcode")
    end

    # Returns the human readable barcode, or nil idif no barcode could be generated
    #
    # @return [String] eg. DN12345R
    def human_barcode
      @human_barcode ||= calculate_human_barcode
    end

    # As with human_barcode, but raises InvalidBarcode if no barcode could be generated
    #
    # @return [String] eg. DN12345R
    def human_barcode!
      human_barcode || raise(InvalidBarcode, "Could not convert #{@machine_barcode} to human_barcode")
    end

    # Returns the internally used checksum
    #
    # @return [SBCF::Checksum] The internally used checksum
    def checksum
      @checksum ||= calculate_checksum
    end

    # Checks is the data provided generate a valid barcode
    # - The number is in the correct range
    # - Any provided checksum is correct
    # - Any provided EAN is correct
    # @return [Bool] true is the barode is valid, false otherwise
    def valid?
      number &&
        calculate_checksum == checksum &&
        check_ean &&
        prefix
    end

    # Checks that the EAN digit of the provided machine barcode is correct
    # In practice this should be enforced by the scanners, so should only be
    # false is the data were input manually
    #
    # @return [Bool] true if the EAN is valid, or the barcode was not a machine barcode originally
    def check_ean
      # the EAN checksum is calculated so that the EAN of the code with checksum added is 0
      # except the new column (the checksum) start with a different weight (so the previous column keep the same weight)
      @machine_barcode.nil? || Ean.validate?(@machine_barcode)
    end

    #
    # Checks that two SBCF::SangerBarcode are the same. Returns true if they represent
    # identical barcodes. Use =~  if you want to also match strings
    # @param other [SBCF::SangerBarcode] The other barcode to match with
    #
    # @return [Boolean] true is barcodes match, false otherwise
    def ==(other)
      return false unless other.is_a?(SangerBarcode)

      human_barcode == other.human_barcode
    end

    #
    # Checks that other matches the format
    # @param other [SBCF::SangerBarcode, String] The barcode or string to match
    #
    # @return [Boolean] true is barcodes match, false otherwise
    def =~(other)
      other_barcode = other.is_a?(SangerBarcode) ? other : SangerBarcode.from_user_input(other)
      self == other_barcode
    end

    ####### PRIVATE METHODS ###################################################################
    private

    def prefix=(prefix)
      @prefix = prefix && Prefix.from_input(prefix)
    end

    def number=(number)
      raise ArgumentError, "Number : #{number} to big to generate a barcode." if number.to_s.size > 7

      @number = number && number.to_i
    end

    def checksum=(checksum)
      @checksum = checksum && Checksum.from_human(checksum)
    end

    # Used internally during barcode creation. Takes a machine barcode and
    # splits it into is component parts
    #
    # @param [String||Int] machine_barcode The 13 digit long ean13 barcode
    # @return [String||Int] Returns the input
    def machine_barcode=(machine_barcode)
      @machine_barcode = machine_barcode.to_i
      match = MACHINE_BARCODE_FORMAT.match(machine_barcode.to_s)
      match && set_from_machine_components(*match)
    end

    def set_from_machine_components(_full, prefix, number, _checksum, _check)
      @prefix = Prefix.from_machine(prefix)
      self.number = number
    end

    def human_barcode=(human_barcode)
      match = HUMAN_BARCODE_FORMAT.match(human_barcode)
      return unless match
      if @checksum_required && match[:checksum].nil?
        raise ChecksumRequired, 'You must supply a complete barcode, including the final letter (eg. DN12345R).'
      end

      self.prefix = match[:prefix]
      self.number = match[:number]
      self.checksum = match[:checksum] unless match[:checksum].empty?
    end

    def calculate_ean13(code)
      Ean.calculate(code)
    end

    def calculate_checksum
      Checksum.from_prefix_and_number(prefix, number)
    end

    # Returns the full length machine barcode
    def calculate_machine_barcode
      sanger_barcode * 10 + calculate_ean13(sanger_barcode) if valid?
    end

    def calculate_human_barcode
      "#{prefix.human}#{number}#{checksum.human}" if valid?
    end

    # Returns the machine barcode minus the EAN13 print checksum.
    def sanger_barcode
      prefix.machine_full + (number * 100) + checksum.machine
    end

    def argument_error!
      raise ArgumentError, 'You must provide either a prefix and a number, or a human or machine barcode'
    end
  end
end
